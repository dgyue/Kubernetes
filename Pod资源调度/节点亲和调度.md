# 节点亲和调度

​	节点亲和是调度程序用来确定Pod对象调度位置的调度法则，这些规则基于节点上的自定义标签和Pod对象上指定的标签选择器进行定义，而支持这种调度机制的有NodeName和NodeAffinity调度插件。简单来说，节点亲和调度机制支持Pod资源定义自身对期望运行的某类节点的倾向性，倾向于运行指定类型的节点即为“亲和”关系，否则为“反亲和”关系。

​	在Pod上定义节点亲和规则时有两种类型的节点亲和关系：强制（required）亲和和首选（preferred）亲和，或分别称为硬亲和与软亲和。强制亲和限定了调度Pod资源时必须要满足的规则，无可用节点时Pod对象会被置为Pending状态，直到满足规则的节点出现。相比较来说，首选规则实现的是一种柔和调度限制，它同样倾向于将Pod运行在某类特定的节点之上，但无法满足调度需求时，调度器将选择一个无法匹配规则的节点，而非将Pod置于Pending状态。

​	在Pod规范上定义节点亲和性和规则的关键点有两个：一是给节点规划并配置合乎期望的标签；二是为Pod对象定义合理的标签选择器。正如preferredDuringSchedulingIgnoredDuringExecution和requiredDuringSchedulingIgnoredDuringExecution字段名中的后半段字符串IgnoredDuringExecution隐含的意义所指，在Pod资源基于节点亲和规则调度至某节点之后，因节点标签发生了改变而变得不再符合Pod定义的亲和规则时，调度器也不会将Pod从此节点上移出，因而亲和性调度仅在调度执行的过程中进行一次即时的判断，而非持续地监视亲和规则是否能够得以满足。

 <img src="/Users/apple/Library/Application Support/typora-user-images/image-20210701221117118.png" alt="image-20210701221117118" style="zoom:50%;" />



## Pod节点选择器

​	Pod资源可以使用.spec.nodeName直接指定要运行的目标节点，也可以基于.spec.nodeSelector指定的标签选择器过滤符合条件的节点作为可用目标节点，最终选择则基于打分机制完成。因此，后者也称为节点选择器。用户事先为特定部分的Node资源对象设定好标签，而后即可配置Pod通过节点选择器实现类似于节点的强制亲和调度。

​	由kubeadm部署的Kubernetes集群默认会为每个节点附加kubernetes.io/arch、kubernetes.io/hostname和kubernetes.io/os等标签，而且主节点还会有一个node-role.kubernetes.io/master标签，其中kubernetes.io/hostname适合NodeName类型的调度。无法满足nodeSelector的调度需求时，我们还可以使用kubectl label nodes/NODE命令为其附加自定义标签。

```shell
# kubectl label nodes/k8s-node01.ilinux.io gpu=
nodes/k8s-node01.ilinux.io labeled
# kubectl label nodes/k8s-node03.ilinux.io gpu=
nodes/k8s-node03.ilinux.io labeled
# kubectl get nodes -l 'gpu' -o custom-columns=NAME:.metadata.name
NAME
k8s-node01.ilinux.io
k8s-node03.ilinux.io
```

示例：定义Pod资源使用节点选择器定义节点亲和机制，它倾向于运行在拥有GPU设备的节点上。

```shell
apiVersion: v1
kind: Pod
metadata:
  name: pod-with-nodeselector
spec:
  containers:
  - name: demoapp
    image: ikubernetes.demoapp:v1.0
  nodeSelector:
    gpu: ''

#按照计划，pod/pod-with-nodeselector资源仅可能会运行在节点k8s-node01或k8s-node03上
# kubectl apply -f pod-with-nodeselector.yaml
pod/pod-with-nodeselectorcreated
# kubectl get pod/pod-with-nodeselector -o jsonpath={.spec.nodeName}
k8s-node03.ilinux.io
```

​	事实上，多数情况下用户都无需关心Pod对象的具体运行位置，除非Pod依赖的特殊条件仅能由部分节点满足时，例如GPU和SSD等。即便如此，也应该尽量避免使用.spec.nodeName静态指定Pod对象的运行位置，而是应该让调度器基于标签和标签选择器为Pod挑选匹配的工作节点。另外，Pod规范中的.spec.nodeSelector仅支持简单等值关系的节点选择器，而.spec.affinity.nodeAffinity支持更灵活的节点选择器表达式，而且可以实现硬亲和与软亲和逻辑。